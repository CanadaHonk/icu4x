// @generated
# [doc = " Implement `DataProvider<CollationMetadataV1Marker>` on the given struct using the data"] # [doc = r" hardcoded in this file. This allows the struct to be used with"] # [doc = r" `icu`'s `_unstable` constructors."] # [doc (hidden)] # [macro_export] macro_rules ! __impl_collator_meta_v1 { ($ provider : ty) => { # [clippy :: msrv = "1.66"] const _ : () = < $ provider > :: MUST_USE_MAKE_PROVIDER_MACRO ; # [clippy :: msrv = "1.66"] impl icu_provider :: DataProvider < icu_collator :: provider :: CollationMetadataV1Marker > for $ provider { fn load (& self , req : icu_provider :: DataRequest ,) -> Result < icu_provider :: DataResponse < icu_collator :: provider :: CollationMetadataV1Marker > , icu_provider :: DataError > { static FR_CA : < icu_collator :: provider :: CollationMetadataV1Marker as icu_provider :: DataMarker > :: Yokeable = icu_collator :: provider :: CollationMetadataV1 { bits : 129u32 , } ; static CCP : < icu_collator :: provider :: CollationMetadataV1Marker as icu_provider :: DataMarker > :: Yokeable = icu_collator :: provider :: CollationMetadataV1 { bits : 1u32 , } ; static TH : < icu_collator :: provider :: CollationMetadataV1Marker as icu_provider :: DataMarker > :: Yokeable = icu_collator :: provider :: CollationMetadataV1 { bits : 297u32 , } ; static RU : < icu_collator :: provider :: CollationMetadataV1Marker as icu_provider :: DataMarker > :: Yokeable = icu_collator :: provider :: CollationMetadataV1 { bits : 33u32 , } ; static AR : < icu_collator :: provider :: CollationMetadataV1Marker as icu_provider :: DataMarker > :: Yokeable = icu_collator :: provider :: CollationMetadataV1 { bits : 41u32 , } ; static EN_US_POSIX : < icu_collator :: provider :: CollationMetadataV1Marker as icu_provider :: DataMarker > :: Yokeable = icu_collator :: provider :: CollationMetadataV1 { bits : 9u32 , } ; static VALUES : [& < icu_collator :: provider :: CollationMetadataV1Marker as icu_provider :: DataMarker > :: Yokeable ; 26usize] = [& AR , & AR , & AR , & AR , & AR , & CCP , & CCP , & CCP , & EN_US_POSIX , & CCP , & EN_US_POSIX , & EN_US_POSIX , & EN_US_POSIX , & EN_US_POSIX , & CCP , & FR_CA , & AR , & AR , & RU , & AR , & AR , & TH , & EN_US_POSIX , & CCP , & CCP , & CCP] ; static KEYS : [& str ; 26usize] = ["ar" , "ar-EG" , "ar-u-co-compat" , "bn" , "bn-u-co-trad" , "ccp" , "en" , "en-001" , "en-US-posix" , "en-ZA" , "es" , "es-AR" , "es-u-co-trad" , "fil" , "fr" , "fr-CA" , "ja" , "ja-u-co-unihan" , "ru" , "sr" , "sr-Latn" , "th" , "tr" , "und" , "und-u-co-emoji" , "und-u-co-eor"] ; if let Ok (payload) = KEYS . binary_search_by (| k | req . locale . strict_cmp (k . as_bytes ()) . reverse ()) . map (| i | * unsafe { VALUES . get_unchecked (i) }) { Ok (icu_provider :: DataResponse { payload : Some (icu_provider :: DataPayload :: from_static_ref (payload)) , metadata : Default :: default () , }) } else { Err (icu_provider :: DataErrorKind :: MissingLocale . with_req (< icu_collator :: provider :: CollationMetadataV1Marker as icu_provider :: KeyedDataMarker > :: KEY , req)) } } } } }